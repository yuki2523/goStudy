package main

import "fmt"

func main() {
	var a int16 = 20
	var b int16 = 30
	var c int64 = 20
	var d int64 = 50

	fmt.Println(a == b) // false
	// fmt.Println(a == c) // 直接报错，类型不同，不可以运算

	// fmt.Println(a * c) // 仍然是因为类型问题而报错
	fmt.Println(a * b) // 600

	fmt.Println(d / c) // 2

	fmt.Println(d % c) // 10

	// var e int64 = d++ // 还是报错，Go里 d++/++d 这种是语句，不能作为表达式用
	// fmt.Println(d++) // 同样是报错的

	// 位运算符(针对2进制)
	fmt.Printf("直接写一个数的类型是：%T\n", 2) // 直接写一个数的类型是：int，那么按照64位系统来，就是64位

	// & 按位与，比如(二进制) 101 和 10
	// 第一位 1 和 0， 1 & 0 = 0
	// 第二位 0 和 1， 0 & 1 = 0
	// 第三位 1 和 无，1 & 无 = 0
	fmt.Printf("5 & 2 = %b\n", 5&2) // 5 & 2 = 0

	// | 按位或，还是用(二进制) 101 和 10
	// 第一位 1 或 0， 1 | 0 = 1
	// 第二位 0 或 1， 0 | 1 = 1
	// 第三位 1 或 无，1 | 无 = 1
	fmt.Printf("5 | 2 = %b\n", 5|2) // 5 | 2 = 111

	// ^ 按位异或，继续(二进制) 101 和 10
	// 第一位 1 异或 0，1 和 0 不同， 1 ^ 0 = 1
	// 第二位 0 异或 1，0 和 1 不同， 0 ^ 1 = 1
	// 第三位 1 异或 无，1 和 无 不同，1 ^ 无 = 1
	fmt.Printf("5 ^ 2 = %b\n", 5^2) // 5 ^ 2 = 111

	// << 位数左移， 使用(二进制) 1
	// 1 << 10,1左移10位就是在1后面加10个0，即：10000000000
	fmt.Printf("1 << 10 = %b = %d\n", 1<<10, 1<<10) // 1 << 10 = 10000000000 = 1024

	// >> 位数右移，用(二进制) 1010
	// 1010 >> 2,右移2位，即：10
	// 1010 >> 3 : 1
	// 1010 >> 4,一位也不剩了，右移的位数大于总位数的话，移多少位都是0
	fmt.Printf("10 >> 2 = %b = %d\n", 10>>2, 10>>2) // 10 >> 2 = 10 = 2
	fmt.Printf("10 >> 4 = %b = %d\n", 10>>4, 10>>4) // 10 >> 4 = 0 = 0
	fmt.Printf("10 >> 5 = %b = %d\n", 10>>5, 10>>5) // 10 >> 5 = 0 = 0

	// 因为这些数字，默认是 int 型，也就是随(64位)系统默认是，是int64(但是和直接写出来的int64不同)
	// 如果 int8，左移一些位数后总位数大于8了，多出来的也取不到，算不进去
	// 同理，int16,32,64，分别是最大16位，32位，64位二进制数
	// m := int8(1) << 10 // 直接报错，1024 overflows int8，位数超了，算不了
	// fmt.Printf("int8的1，1 << 10 = %b", m)

	// 赋值运算符
	// -=，+=，*=，/=，%=，这5个都是一个套路的
	// 简单写一写位运算的赋值运算
	o := 10 // 1010
	p := 2  // 10
	// o &= p
	// fmt.Printf("%b = %d\n", o, o) // 10 = 2
	o |= p
	fmt.Printf("%b = %d\n", o, o) // 1010 = 10
	// >>=, <<=, ^= 也是同理的
}
