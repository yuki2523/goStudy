package main

import "fmt"

func main() {
	// 1、删除数组里的值
	s1 := []int{1, 2, 3, 4, 5}
	// 我想把s1里的3给删掉
	// 但是Go里没有提供原生的删除方式，活用切割和append处理这个问题
	s1 = append(s1[:2], s1[3:]...) // 切割再拼接的方式删除值
	fmt.Println(s1)                // [1 2 4 5]

	// 2、底层数组和切片直接互相影响
	s2 := [...]int{1, 3, 5, 7, 9} // 定义一个数组 s2
	s3 := s2[:]                   // 通过数组 s2 获取切片 s3
	// 先修改底层数组，看看切片的变化
	s2[0] = 100
	fmt.Println(s3) // [100 3 5 7 9]
	// 再修改切片，看看数组的变化
	s3[4] = 500
	fmt.Println(s2) // [100 3 5 7 500]
	// 结论：切片不存值，值都在底层数组，数组修改，切片取到的值也会变化，修改切片，就是在修改底层数组里的值

	// 3、切片框了一块连续的内存空间
	// 那么如果用：对切片进行切割，再append拼接起来的方式去删除切片里的值，底层数组会发生什么变化呢？
	s4 := [...]string{"a", "b", "c", "d", "e", "f", "g", "h"}
	s5 := s4[:]         // s5是以s4为底层数组的切片
	fmt.Println(s4, s5) // [a b c d e f g h] [a b c d e f g h]
	s5 = append(s5[0:2], s5[5:]...)
	fmt.Println(s4, s5) // [a b f g h f g h] [a b f g h]
	// 底层数组s4变成了[a b f g h f g h]
	// 因为切片是一块连续的内存空间框起来的，那么只能通过修改底层数组来满足这次修改(删除了"c", "d", "e")
	// 删掉了三个，左移后，后面缺三个，就由最后三个补齐
	// 可以看到Go的做法是把底层数组，那个被删掉的数移除，然后从那个移除的元素开始右边整体向左移
	// 底层数组的总位数不变，后面缺的,缺几个就用最后几个元素的值补齐

	// 4、一道练习
	a := make([]int, 5, 10)
	fmt.Println(a) // [0 0 0 0 0]
	for i := 0; i < 10; i++ {
		a = append(a, i)
	}
	fmt.Println(a) // [0 0 0 0 0 0 1 2 3 4 5 6 7 8 9]
	// 题目问的是for循环后 a 指向的切片的值
	// 实质也是在考察一个基础，make([]int, 5, 10)后初始化的一个切片，是len为5的，而且全部用0填充了
	// 之后 append 函数每次只是在后面追加，因此结果是 6个0，之后从 1-9
}
