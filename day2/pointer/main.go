package main

import "fmt"

func main() {
	// 指针
	// &变量:取地址
	// *地址值:通过地址值取变量

	a := 10
	// 现在 b 和 c 的数据类型是 *int,存着a的地址值
	b := &a
	c := &a
	fmt.Printf("%T,%T\n", b, c) // *int,*int
	// 指针数据类型的类型就是: *数据类型
	// 根据实践发现，支持双重指针

	// 现在使用 *b,*c，有种在使用引用数据类型的感觉
	fmt.Println(a, *b, *c) // 10 10
	a = 100
	// *b,*c 会随着a的值的改变而改变
	fmt.Println(a, *b, *c) // 100 100
	// 通过一个指针去修改值，也是可以带着一起改变的，这全能当引用数据类型玩了
	*b = 1000
	fmt.Println(a, *b, *c) // 1000 1000 1000

	// 指针类型可以直接var声明，但是通过实验 a := *int(0xadada000) 这种是不支持的
	var d *int                       // 这样声明出来的指针类型，拿不到地址值,为 nil
	fmt.Printf("类型:%T,值:%v\n", d, d) // 类型:*int,值:<nil>
	// *d = 100 // 报错了，空地址值，*地址值变量 = 值，是无法存值进去的

	// 可以使用 new 函数申请一块内存地址值
	// 语法: new(type)
	e := new(int) // 这样可以给指针变量 e 申请到一块内存地址，不是 nil 了,而且申请后的地址值指向的值是 0
	fmt.Printf("类型:%T,值:%v,指针取的值:%v,指针取的值的类型:%T\n", e, e, *e, *e)
	// 类型:*int,值:0xc0000a00d8,指针取的值:0,指针取的值的类型:int

	f := new(string) // 字符串新 new 出来的，指向的值是空字符 ""
	fmt.Printf("类型:%T,值:%v,指针取的值:%#v,指针取的值的类型:%T\n", f, f, *f, *f)
	// 类型:*string,值:0xc0000421f0,指针取的值:"",指针取的值的类型:string
}
